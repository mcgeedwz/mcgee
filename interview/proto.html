<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>原型链</title>
	</head>
	<body>
		<script type="text/javascript">
			// 第一种方式：字面量
			var o1 = { name: 'o1' }
			var o2 = new Object({ name: 'o2' })
			// 第二种方式：构造函数
			var M = function (name) {
				this.name = name
			}
			var o3 = new M('o3')
			// 第三种方式：Object.create
			var p = { name: 'p' }
			var o4 = Object.create(p)

			M.prototype.say = function () {
				console.log('say hi')
			}
			var o5 = new M('o5')

			/**
			 * new的过程做了什么
			 * 1 首先创建一个新对象，这个新对象的__proto__属性指向构造函数的prototype属性
			 * 2 此时构造函数执行环境的this指向这个新对象
			 * 3 执行构造函数中的代码，一般是通过this给新对象添加新的成员属性或方法。
			 * 4 最后返回这个新对象
			 */

			var new2 = function (func) {
				var o = Object.create(func.prototype)
				var k = func.call(o)
				if (typeof k === 'object') {
					return k
				} else {
					return o
				}
			}
			/**
			 * 课外扩展
			 * 传参数版本
			 */
			// func是构造函数，...args是需要传给构造函数的参数
			function myNew(func, ...args) {
				// 创建一个空对象，并且指定原型为func.prototype
				var obj = Object.create(func.prototype)
				// new构造函数时要执行函数，同时指定this
				func.call(obj, ...args)
				// 最后return这个对象
				return obj
			}

			/**
			 * 课外扩展
			 * for in 和 for if 的区别
			 * for in 遍历对象的可枚举属性(enumerable) 包括原型链上的非自有可枚举属性 得到key 类型string 通常用hasOwnProperty()过滤非自有属性
			 * for of es6 方法 拥有迭代器对象（iterator）的集合 适用数组 得到value值 不包括原型链上的属性 循环普通的对象需要通过Object.keys搭配使用
			 * for of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象（iterator）的集合，但是不能遍历对象，因为没有迭代器对象
			 * 但如果想遍历对象的属性，你可以用for in循环（这也是它的本职工作）或用内建的Object.keys()方法
			 */
		</script>
	</body>
</html>
